<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>SnarkJS Part II</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="styling.css" />
</head>
<body>
<h1 id="zero-knowledge-proofs-circomsnarkjs-part-ii">Zero-Knowledge
Proofs: Circom/SnarkJS Part II</h1>
<h2 id="tldr">TL;DR</h2>
<ol type="1">
<li>Download the files from Moodle</li>
<li>Move <code>mastermind.circom</code> and <code>circomlib/</code> to
<code>mycircuits/</code> from the previous part.</li>
<li>Follow the instructions in <code>mastermind.circom</code> to
complete the circuit.</li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>Welcome to the second part of the Circom/SnarkJS exercises!</p>
<p>In the previous part, you familiarized yourself with the Circom
Language, created relatively small circuits and maybe even computed your
first ever SNARK! In the second part we build on top of this and want to
design a circuit for the board game “Mastermind”.</p>
<p>If you’re not familiar with Mastermind, you can find the rules on <a
href="https://en.wikipedia.org/wiki/Mastermind_(board_game)">Wikipedia</a>.
Essentially, it is a guessing game where one player comes up with a
color sequence and places colored pegs behind a visual barrier
accordingly. The other player has to guess it. After each guess, the
player is told how many positions of its guess were correct, but not
which ones! In the original game, the player would also learn how many
positions of the guess have the correct color but are in an incorrect
position. For simplicity, we omit this in our SNARK.</p>
<p>To securely play Mastermind with SNARKs, our circuit has to do three
things:</p>
<p>Firstly, one player needs to compute a commitment to a color
sequence. Our circuit needs to ensure that the prover knows the color
sequence inside the commitment. All other computations are performed
over this color sequence.</p>
<p>Secondly, the circuit should also have an input for the guess of the
other player. It should then compute how many positions of the guess are
correct and output the result without revealing anything more about the
original sequence. This is the main part of the game.</p>
<p>Thirdly, the circuit has to check that the color sequences actually
contains only valid colors. This is called a domain check. In the
description of ZK protocols in the lecture, we omitted domain checks. In
practice, however, they are very important and leaving them away creates
room for attacks.</p>
<p>Your goal of this exercise session is to implement these three parts.
Afterwards you should be able to play Mastermind with your friends via a
messenger or e-mail.</p>
<h2 id="your-tasks">Your Tasks</h2>
<p>If you want to, get together in groups of two or three and split up
the tasks between you.</p>
<p>Make sure that you have downloaded the exercise files from Moodle. It
should include the <code>mastermind.circom</code> template file, which
contains all further task descriptions. Copy
<code>mastermind.circom</code> and <code>circomlib/</code> into the
<code>mycircuits/</code> directory from the first part so that you can
use it inside the Docker container.</p>
<p><strong>Resources:</strong> The following resources might help you
solve the tasks: - <a
href="https://docs.circom.io/circom-language/signals/">Circom
Documentation</a> - <a
href="https://github.com/iden3/snarkjs/blob/master/README.md">snarkJS
README</a> - <a
href="https://github.com/iden3/circomlib/blob/master/circuits/poseidon.circom">CircomLib</a></p>
<p><strong>Hint:</strong> There also is a file called
<code>mastermind_solution.circom</code>. If you get stuck with one task,
let the solution inspire you and move on to the next task, rather than
losing too much time.</p>
<p><strong>Hint:</strong> If you’ve forgotten how to start your Docker
container, try <code>docker-compose start snarkjs</code> or
<code>docker-compose run snarkjs</code>. If you haven’t set up your
Docker container in the first place, please follow the instructions from
the first part. You can find a self-contained <code>README.html</code>
in the files from the first exercise part.</p>
<h2 id="after-you-are-done-playing-the-game">After You Are Done –
Playing the Game</h2>
<p>If you are done with the tasks and you are confident about the
correctness of your circuit, it is time to start playing the game!</p>
<ol type="1">
<li>Find a friend or collegue you want to play with.</li>
<li>Agree on whose circuit to use. Prover and verifier need to work over
the same circuit.</li>
<li>Agree on whose setup to use. In applications where security is
important, you would re-run the Powers-of-Tau ceremony and make sure
that everone contributes some randomness, but this takes a couple of
minutes so it’s easier to use the setup you created last time.</li>
<li>To give input to the circuit and compute SNARKs, create a file
called <code>input.json</code> and follow the instructions in the <a
href="https://github.com/iden3/snarkjs/blob/master/README.md">snarkJS
README</a> to create the proof. The prover starts by committing to the
color sequence and sending it to the verifier. The verifier then
repeatedly sends his guesses to the prover, the prover sends back the
result and the SNARK to prove their correctness. The verifier only has
to verify that the commitment of the prover always is the same so that
he doesn’t change the color sequence mid-game.</li>
</ol>
<p>Have fun playing the game!</p>
<p>(If you get tired of writing json files and compiling proofs by hand,
you can also develop a node app for that. SnarkJS has a very good
interface. Let the example in its README inspire you.)</p>
<h2 id="free-bonus-content-for-interested-students">Free Bonus Content
for Interested Students</h2>
<ul>
<li>In the first part, the question came up how we validate circuits.
Validating circuits is very important but also difficult. In fact, a
look at the <a href="https://github.com/0xPARC/zk-bug-tracker">ZK Bug
Tracker</a> shows how many vulnerabilities in ZK proof systems concern
the circuit specification.</li>
<li>For the commitment scheme, we used the Poseidon hash function. In
contrast to more common hash functions like the ones from the SHA
family, Poseidon was developed especially with ZK systems in mind, so it
is a natural fit for our purpos: <a
href="https://eprint.iacr.org/2019/458">Poseidon: A New Hash Function
for Zero-Knowledge Proof Systems</a></li>
</ul>
<p>Author: Konrad Klier, Nov 2024</p>
</body>
</html>
